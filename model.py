# -*- coding: utf-8 -*-
"""MODEL

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tfFRgeksbySaS9mBetMTN0fy5NIXoQ7v
"""

import pandas as pd

try:
    df = pd.read_csv("/content/drive/MyDrive/Hackathon/udemy_courses.csv")
    print("Dataset loaded successfully!")
except FileNotFoundError:
    print("Error: udemy_courses.csv not found.  Make sure it's in the Colab environment.")
    from google.colab import files
    uploaded = files.upload()
    import io
    df = pd.read_csv(io.BytesIO(uploaded['udemy_courses.csv']))

print(df.head())  # Print the first few rows
print(df.info())  # Print information about the columns (data types, missing values)

skills = [
    # Business Finance
    "Accounting", "Financial Modeling", "Investment Analysis", "Corporate Finance",
    "Risk Management", "Financial Planning", "Cryptocurrency", "Stock Trading",
    "Economics", "Business Strategy", "Entrepreneurship", "Taxation",
    "Budgeting", "Bookkeeping", "Venture Capital", "Mergers and Acquisitions",
    "Banking", "Supply Chain Finance", "Wealth Management", "Fintech",

    # Graphic Design
    "UI/UX Design", "Adobe Photoshop", "Adobe Illustrator", "Figma",
    "Canva", "Typography", "Logo Design", "Branding", "Motion Graphics",
    "3D Modeling", "Blender", "Maya", "Sketch", "Product Design",
    "Web Design", "Photo Editing", "Digital Illustration", "Infographic Design",
    "Packaging Design", "Visual Storytelling", "Color Theory",

    # Musical Instruments
    "Music Theory", "Piano", "Guitar", "Violin", "Drums", "Bass Guitar",
    "Singing", "Songwriting", "Music Production", "Audio Engineering",
    "DAW (Digital Audio Workstation)", "GarageBand", "FL Studio", "Ableton Live",
    "Mixing and Mastering", "Jazz Improvisation", "Classical Music", "Ear Training",
    "Synthesizers", "Sound Design", "Orchestration",

    # Web Development
    "HTML", "CSS", "JavaScript", "React.js", "Node.js", "Vue.js", "PHP",
    "Django", "Flask", "Bootstrap", "Tailwind CSS", "TypeScript",
    "WordPress", "SEO for Web", "Web Performance Optimization",
    "Progressive Web Apps (PWA)", "RESTful APIs", "GraphQL",
    "E-commerce Development", "Frontend Development", "Backend Development",
    "Full-Stack Development"
]

def extract_skills_keyword(text):
    if not isinstance(text, str):  # Handle potential non-string values
        return []
    found_skills = [skill for skill in skills if skill.lower() in text.lower()]
    return found_skills

df['skills'] = df['course_title'].apply(extract_skills_keyword)  # Combine skills from both
df['skills'] = df['skills'].apply(lambda x: list(set(x))) # remove duplicate skill results
print(df[['course_title', 'skills']].head())  # Print a few rows to check results

skill_to_courses = {}
for skill in skills:
    courses_with_skill = df[df['skills'].apply(lambda x: skill in x)]['course_title'].tolist()
    skill_to_courses[skill] = courses_with_skill

# Print the mapping for one skill (for testing)
print(f"\nCourses teaching Python: {skill_to_courses.get('Python', [])}")

# Normalize dictionary keys to lowercase for case-insensitive search
skill_to_courses = {skill.lower(): courses for skill, courses in skill_to_courses.items()}

# Get user input and normalize it
skill_input = input("Enter a skill to search for courses: ").strip().lower()

# Search for courses
courses_for_skill = skill_to_courses.get(skill_input, [])

if courses_for_skill:
    print(f"\nCourses teaching {skill_input.capitalize()}:")
    for course in courses_for_skill:
        print(f"- {course}")
else:
    print(f"No courses found for the skill: {skill_input.capitalize()}")

!pip install spacy
!python -m spacy download en_core_web_sm

import spacy

nlp = spacy.load("en_core_web_sm")

def extract_skills_ner(text):
    if not isinstance(text, str):  # Handle potential non-string values
        return []
    doc = nlp(text)
    skills = [ent.text for ent in doc.ents if ent.label_ in ["SKILL", "PRODUCT", "ORG"]] # ORG sometimes useful in technical texts
    return list(set(skills))  # Remove duplicates

# Modify DataFrame (replace the keyword skills function )
df['skills'] = df['course_title'].apply(extract_skills_ner)
df['skills'] = df['skills'].apply(lambda x: list(set(x)))
print(df[['course_title', 'skills']].head())  # Verify output

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
import pandas as pd
import numpy as np

# Debugging: Print initial data issues
print("Initial NaN counts:\n", df.isnull().sum())

# Remove rows with NaN in critical columns
df_cleaned = df.dropna(subset=['num_subscribers', 'num_reviews', 'price', 'level', 'is_paid'])

# Debugging: Check how many rows remain
print(f"Rows remaining after dropna: {df_cleaned.shape[0]}")

# Convert 'is_paid' safely
df_cleaned.loc[:, 'is_paid'] = pd.to_numeric(df_cleaned['is_paid'], errors='coerce')

# Check unique values after conversion
print("\nUnique 'is_paid' values after conversion:", df_cleaned['is_paid'].unique())

# Feature selection
X = df_cleaned[['num_subscribers', 'num_reviews', 'price', 'is_paid', 'level']].copy()
y = df_cleaned['num_subscribers']

# Ensure X is not empty
if X.shape[0] == 0:
    raise ValueError("After filtering, X is empty! Check the data cleaning steps.")

# One-Hot Encoding for categorical features
ct = ColumnTransformer(
    transformers=[('encoder', OneHotEncoder(handle_unknown='ignore'), ['level'])],
    remainder='passthrough'
)

X = ct.fit_transform(X)  # One-hot encode categorical variables

# Scale numerical features
scaler = StandardScaler()
X = scaler.fit_transform(X)

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Predictions & Evaluation
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
print(f"Mean Squared Error: {mse}")

import pandas as pd
import numpy as np
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer

# Assuming 'scaler' and 'ct' were already trained on the training data
# Ensure that df is cleaned before applying this function

numerical_columns = ['num_subscribers', 'num_reviews', 'price', 'is_paid']
categorical_columns = ['level']

# Function to predict quality (consistent with training pipeline)
def predict_quality(row):
    # Convert row into a DataFrame
    features = row[numerical_columns + categorical_columns].to_frame().T

    # Ensure 'is_paid' is numeric
    features['is_paid'] = pd.to_numeric(features['is_paid'], errors='coerce').fillna(0)

    # Convert all numerical columns to numeric type
    features[numerical_columns] = features[numerical_columns].apply(pd.to_numeric, errors='coerce')

    # Handle NaNs in numerical columns
    features[numerical_columns] = features[numerical_columns].fillna(features[numerical_columns].mean())

    # Apply the pre-fitted ColumnTransformer (including One-Hot Encoding)
    features_transformed = ct.transform(features)  # Do NOT fit again

    # Apply pre-trained scaler
    features_scaled = scaler.transform(features_transformed)  # Do NOT fit again

    # Predict using the trained model
    quality = model.predict(features_scaled)
    return quality[0]

# Apply the prediction function to each row
df['predicted_quality'] = df.apply(predict_quality, axis=1)

# Sort by predicted quality
df.sort_values(by='predicted_quality', ascending=False, inplace=True)

# User input to filter courses
skill_input = input("Enter a skill to search for courses: ").lower().strip()

# Normalize skills column (convert to lowercase for case-insensitive search)
df['skills'] = df['skills'].apply(lambda x: [s.lower() for s in x])

# Filter top 10 courses for the skill
courses_for_skill = df[df['skills'].apply(lambda x: skill_input in x)][['course_title', 'predicted_quality']].head(10)

# Display results
print(f"\nTop 10 courses teaching {skill_input} (sorted by quality):")
print(courses_for_skill)